diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..2f5c2b1
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,78 @@
+SHELL := /bin/bash
+FILE ?= /tmp/perf_smoke_big.tex
+J ?= 8
+
+.PHONY: all build clean verify service-run service-stop
+
+all: build
+
+build:
+	dune build @all -j $(J)
+
+clean:
+	dune clean
+
+# Launch the service (2 workers, hedge=10ms), kill any stale one, unlink socket
+service-run:
+	-pkill -f main_service || true
+	-rm -f /tmp/l0_lex_svc.sock
+	ulimit -n 65536; \
+	_build/default/latex-parse/src/main_service.exe &
+	@sleep 0.3
+	@echo "[service] started on /tmp/l0_lex_svc.sock"
+
+service-stop:
+	-pkill -f main_service || true
+	@echo "[service] stopped"
+
+# Quick verification: build, time selftest, IPC propcheck, run service,
+# then 4Ã—2500 concurrent requests against the service
+verify: build service-run
+	_build/default/latex-parse/bench/time_selftest.exe
+	_build/default/latex-parse/bench/ipc_propcheck.exe
+	@if [[ ! -f "$(FILE)" ]]; then echo "Set FILE=<path to perf_smoke_big.tex>"; exit 2; fi
+	_build/default/latex-parse/bench/run_service_bench_concurrent.exe "$(FILE)" 10000 4
+	@echo "[verify] tail CSV (slowest-100):"
+	@tail -n 10 /tmp/l0_service_tail.csv || true
+	@$(MAKE) service-stop
diff --git a/latex-parse/src/dune b/latex-parse/src/dune
new file mode 100644
index 0000000..b3b0c45
--- /dev/null
+++ b/latex-parse/src/dune
@@ -0,0 +1,25 @@
+(library
+ (name latex_parse_lib)
+ (modules
+  config clock hedge_timer mlock meminfo gc_prep pretouch arena ipc
+  real_processor worker broker service_bracket)
+ (libraries unix threads)
+ (foreign_stubs
+  (language c)
+  (names clock_stubs hedge_timer_stubs mlock_stubs meminfo_stubs)))
+
+(executable
+ (name main_service)
+ (modules main_service)
+ (libraries latex_parse_lib unix threads))
diff --git a/latex-parse/bench/dune b/latex-parse/bench/dune
new file mode 100644
index 0000000..0ebfbcb
--- /dev/null
+++ b/latex-parse/bench/dune
@@ -0,0 +1,17 @@
+(executable
+ (name run_service_bench_concurrent)
+ (modules run_service_bench_concurrent percentiles_strict)
+ (libraries unix threads latex_parse_lib))
+
+(executable
+ (name ipc_propcheck)
+ (modules ipc_propcheck)
+ (libraries unix latex_parse_lib))
+
+(executable
+ (name time_selftest)
+ (modules time_selftest)
+ (libraries unix latex_parse_lib))
diff --git a/latex-parse/src/config.ml b/latex-parse/src/config.ml
new file mode 100644
index 0000000..0a9d0e7
--- /dev/null
+++ b/latex-parse/src/config.ml
@@ -0,0 +1,28 @@
+let page_bytes                   = 4096
+
+(* Hedging *)
+let hedge_timer_ms_default       = 10
+
+(* GC / rotation budgets (per worker, since last spawn) *)
+let minor_heap_bytes             = 256 * 1024 * 1024
+let gc_space_overhead            = 10_000
+let gc_max_overhead              = 10_000
+let gc_full_major_budget_mb      = 256
+
+(* Per-spawn deltas, not cumulative forever *)
+let worker_alloc_budget_mb       = 5000   (* 5 GB since spawn, then rotate *)
+let worker_major_cycles_budget   = 50     (* full majors since spawn, then rotate *)
+
+(* Arena: 3M tokens ~ 48MB per arena; double buffer ~ 96MB *)
+let arenas_tokens_cap            = 3_000_000
+
+(* Service socket *)
+let service_sock_path            = "/tmp/l0_lex_svc.sock"
+
+(* Limits *)
+let max_req_bytes                = 2 * 1024 * 1024
+
+(* Tail CSV *)
+let tail_csv_path                = "/tmp/l0_service_tail.csv"
+let tail_trace_keep              = 100
+
+let pool_cores                   = [|0;1|]
diff --git a/latex-parse/src/clock_stubs.c b/latex-parse/src/clock_stubs.c
new file mode 100644
index 0000000..7eacb9e
--- /dev/null
+++ b/latex-parse/src/clock_stubs.c
@@ -0,0 +1,17 @@
+#define _GNU_SOURCE
+#include <time.h>
+#include <stdint.h>
+#include <caml/mlvalues.h>
+#include <caml/alloc.h>
+
+static int64_t now_ns_mono(void){
+  struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);
+  return (int64_t)ts.tv_sec * 1000000000LL + ts.tv_nsec;
+}
+
+CAMLprim value ocaml_clock_monotonic_ns(value unit){
+  return caml_copy_int64(now_ns_mono());
+}
diff --git a/latex-parse/src/clock.ml b/latex-parse/src/clock.ml
new file mode 100644
index 0000000..9a57f8a
--- /dev/null
+++ b/latex-parse/src/clock.ml
@@ -0,0 +1,6 @@
+external now_ns : unit -> int64 = "ocaml_clock_monotonic_ns"
+let now () = now_ns ()
+let ns_of_ms ms = Int64.mul 1_000_000L (Int64.of_int ms)
+let ms_of_ns ns = Int64.to_float ns /. 1.0e6
diff --git a/latex-parse/src/hedge_timer_stubs.c b/latex-parse/src/hedge_timer_stubs.c
new file mode 100644
index 0000000..3f5360f
--- /dev/null
+++ b/latex-parse/src/hedge_timer_stubs.c
@@ -0,0 +1,132 @@
+#include <caml/mlvalues.h>
+#include <caml/alloc.h>
+#include <caml/unixsupport.h>
+#include <caml/threads.h>
+#include <stdint.h>
+#include <unistd.h>
+
+#if defined(__APPLE__)
+  #include <sys/event.h>
+  #include <sys/time.h>
+
+  CAMLprim value ocaml_ht_create(value unit){
+    int kq = kqueue(); if (kq < 0) uerror("kqueue", Nothing); return Val_int(kq);
+  }
+  CAMLprim value ocaml_ht_arm_ns(value vkq, value vns){
+    int kq = Int_val(vkq); int64_t ns = Int64_val(vns);
+    struct kevent kev;
+    EV_SET(&kev, 1, EVFILT_TIMER, EV_ADD | EV_ONESHOT, 0, (int)(ns/1000000LL), NULL);
+    if (kevent(kq, &kev, 1, NULL, 0, NULL) < 0) uerror("kevent(timer)", Nothing);
+    return Val_unit;
+  }
+  CAMLprim value ocaml_ht_wait2(value vkq, value vfd1, value vfd2){
+    CAMLparam3(vkq, vfd1, vfd2);
+    int kq  = Int_val(vkq);
+    int fd1 = Int_val(vfd1);
+    int fd2 = Int_val(vfd2);
+    struct kevent kevset[2]; int nset=0;
+    if (fd1 >= 0) { EV_SET(&kevset[nset++], fd1, EVFILT_READ, EV_ADD|EV_ENABLE, 0, 0, NULL); }
+    if (fd2 >= 0) { EV_SET(&kevset[nset++], fd2, EVFILT_READ, EV_ADD|EV_ENABLE, 0, 0, NULL); }
+    if (nset>0)  { if (kevent(kq, kevset, nset, NULL, 0, NULL) < 0) uerror("kevent(add)", Nothing); }
+    struct kevent out[3];
+    caml_enter_blocking_section();
+      int nev = kevent(kq, NULL, 0, out, 3, NULL);
+    caml_leave_blocking_section();
+    if (nev < 0) uerror("kevent(wait)", Nothing);
+    int timer_fired = 0; int which = -1;
+    for (int i=0;i<nev;i++){
+      if (out[i].filter == EVFILT_TIMER) timer_fired = 1;
+      if (out[i].filter == EVFILT_READ){
+        if (fd1 >= 0 && (int)out[i].ident == fd1) which = fd1;
+        else if (fd2 >= 0 && (int)out[i].ident == fd2) which = fd2;
+      }
+    }
+    value t = caml_alloc_tuple(2);
+    Store_field(t,0, Val_int(timer_fired));
+    Store_field(t,1, Val_int(which));
+    CAMLreturn(t);
+  }
+#else
+  #include <sys/timerfd.h>
+  #include <sys/epoll.h>
+  CAMLprim value ocaml_ht_create(value unit){
+    int ep = epoll_create1(EPOLL_CLOEXEC); if (ep<0) uerror("epoll_create1", Nothing); return Val_int(ep);
+  }
+  CAMLprim value ocaml_ht_arm_ns(value vep, value vns){
+    int ep = Int_val(vep); int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);
+    if (tfd < 0) uerror("timerfd_create", Nothing);
+    struct itimerspec its = {0}; int64_t ns = Int64_val(vns);
+    its.it_value.tv_sec = ns/1000000000LL; its.it_value.tv_nsec = ns%1000000000LL;
+    if (timerfd_settime(tfd, 0, &its, NULL)<0) uerror("timerfd_settime", Nothing);
+    struct epoll_event ev = { .events = EPOLLIN, .data.fd = tfd };
+    if (epoll_ctl(ep, EPOLL_CTL_ADD, tfd, &ev) < 0) uerror("epoll_ctl(timer)", Nothing);
+    return Val_unit;
+  }
+  CAMLprim value ocaml_ht_wait2(value vep, value vfd1, value vfd2){
+    CAMLparam3(vep, vfd1, vfd2);
+    int ep = Int_val(vep);
+    int fd1 = Int_val(vfd1);
+    int fd2 = Int_val(vfd2);
+    struct epoll_event ev1 = { .events = EPOLLIN, .data.fd = fd1 };
+    struct epoll_event ev2 = { .events = EPOLLIN, .data.fd = fd2 };
+    if (fd1 >= 0) epoll_ctl(ep, EPOLL_CTL_ADD, fd1, &ev1);
+    if (fd2 >= 0) epoll_ctl(ep, EPOLL_CTL_ADD, fd2, &ev2);
+    struct epoll_event out;
+    caml_enter_blocking_section();
+      int n = epoll_wait(ep, &out, 1, -1);
+    caml_leave_blocking_section();
+    if (n<0) uerror("epoll_wait", Nothing);
+    int timer_fired = 0; int which = -1;
+    if (out.data.fd == fd1) which = fd1;
+    else if (out.data.fd == fd2) which = fd2;
+    else timer_fired = 1;
+    value t = caml_alloc_tuple(2);
+    Store_field(t,0, Val_int(timer_fired));
+    Store_field(t,1, Val_int(which));
+    CAMLreturn(t);
+  }
+#endif
diff --git a/latex-parse/src/hedge_timer.ml b/latex-parse/src/hedge_timer.ml
new file mode 100644
index 0000000..ee09957
--- /dev/null
+++ b/latex-parse/src/hedge_timer.ml
@@ -0,0 +1,10 @@
+external ht_create  : unit -> Unix.file_descr = "ocaml_ht_create"
+external ht_arm_ns  : Unix.file_descr -> int64 -> unit = "ocaml_ht_arm_ns"
+external ht_wait2   : Unix.file_descr -> int -> int -> (int * int) = "ocaml_ht_wait2"
+
+type t = { k: Unix.file_descr }
+let create () = { k = ht_create () }
+let arm t ~ns = ht_arm_ns t.k ns
+let wait_two t ~fd1 ~fd2 =
+  let (tf, which) = ht_wait2 t.k fd1 fd2 in
+  (tf, which)
diff --git a/latex-parse/src/mlock_stubs.c b/latex-parse/src/mlock_stubs.c
new file mode 100644
index 0000000..ad0a4d6
--- /dev/null
+++ b/latex-parse/src/mlock_stubs.c
@@ -0,0 +1,19 @@
+#include <caml/mlvalues.h>
+#include <sys/mman.h>
+#include <sys/resource.h>
+
+CAMLprim value ocaml_mlockall(value unit){
+#ifdef __APPLE__
+  mlockall(MCL_CURRENT|MCL_FUTURE);
+#else
+  struct rlimit r={RLIM_INFINITY,RLIM_INFINITY}; setrlimit(RLIMIT_MEMLOCK,&r);
+  mlockall(MCL_CURRENT|MCL_FUTURE);
+#endif
+  return Val_unit;
+}
diff --git a/latex-parse/src/mlock.ml b/latex-parse/src/mlock.ml
new file mode 100644
index 0000000..6f1a9f8
--- /dev/null
+++ b/latex-parse/src/mlock.ml
@@ -0,0 +1,3 @@
+external mlockall : unit -> unit = "ocaml_mlockall"
+let init () = try mlockall () with _ -> ()
diff --git a/latex-parse/src/meminfo_stubs.c b/latex-parse/src/meminfo_stubs.c
new file mode 100644
index 0000000..e2f4c8d
--- /dev/null
+++ b/latex-parse/src/meminfo_stubs.c
@@ -0,0 +1,32 @@
+#include <caml/mlvalues.h>
+#include <caml/alloc.h>
+#ifdef __APPLE__
+#include <mach/mach.h>
+#endif
+
+CAMLprim value ocaml_task_meminfo(value unit){
+#ifdef __APPLE__
+  struct task_basic_info_64 info;
+  mach_msg_type_number_t count = TASK_BASIC_INFO_64_COUNT;
+  kern_return_t kr = task_info(mach_task_self(), TASK_BASIC_INFO_64,
+                               (task_info_t)&info, &count);
+  if (kr != KERN_SUCCESS){
+    value t = caml_alloc_tuple(2);
+    Store_field(t,0, Val_int(0)); Store_field(t,1, Val_int(0)); return t;
+  }
+  value t = caml_alloc_tuple(2);
+  Store_field(t,0, caml_copy_int64((int64_t)info.resident_size));
+  Store_field(t,1, caml_copy_int64((int64_t)info.virtual_size));
+  return t;
+#else
+  value t = caml_alloc_tuple(2);
+  Store_field(t,0, Val_int(0));
+  Store_field(t,1, Val_int(0));
+  return t;
+#endif
+}
diff --git a/latex-parse/src/meminfo.ml b/latex-parse/src/meminfo.ml
new file mode 100644
index 0000000..4a5c9a2
--- /dev/null
+++ b/latex-parse/src/meminfo.ml
@@ -0,0 +1,3 @@
+external task_meminfo : unit -> (int64 * int64) = "ocaml_task_meminfo"
+let rss_mb () = let (rss, _) = task_meminfo () in Int64.to_float rss /. 1.0e6
diff --git a/latex-parse/src/gc_prep.ml b/latex-parse/src/gc_prep.ml
new file mode 100644
index 0000000..e7b6a51
--- /dev/null
+++ b/latex-parse/src/gc_prep.ml
@@ -0,0 +1,23 @@
+let words_total () = let s = Gc.quick_stat () in s.minor_words +. s.major_words
+let last_full = ref 0.0
+
+let drain_major ?(slice=10_000) () =
+  let rec loop () = if Gc.major_slice slice <> 0 then loop () in loop ()
+
+let prepay () =
+  drain_major ();
+  let delta_words = (words_total ()) -. !last_full in
+  let delta_mb = delta_words *. (float Sys.word_size /. 8.0) /. 1_048_576.0 in
+  if delta_mb >= float Config.gc_full_major_budget_mb then (Gc.full_major (); last_full := words_total ())
+
+let init_gc () =
+  let g = Gc.get () in
+  Gc.set { g with
+    minor_heap_size   = Config.minor_heap_bytes;
+    space_overhead    = Config.gc_space_overhead;
+    max_overhead      = Config.gc_max_overhead;
+    allocation_policy = 1;
+  };
+  Gc.compact (); last_full := words_total ()
diff --git a/latex-parse/src/pretouch.ml b/latex-parse/src/pretouch.ml
new file mode 100644
index 0000000..7a6fb3e
--- /dev/null
+++ b/latex-parse/src/pretouch.ml
@@ -0,0 +1,17 @@
+let pre_touch_bytes (b:bytes) ~page =
+  let n = Bytes.length b in
+  let rec loop i = if i < n then (ignore (Bytes.unsafe_get b i); loop (i+page)) in loop 0
+
+let pre_touch_ba_1 (type a) (type b)
+  (ba:(a,b,Bigarray.c_layout) Bigarray.Array1.t)
+  ~(elem_bytes:int) ~(elems:int) ~(page:int) =
+  let open Bigarray in
+  let dim = Array1.dim ba in
+  let n = min elems dim in
+  let step = max 1 (page / elem_bytes) in
+  let rec loop i = if i < n then (ignore (Array1.unsafe_get ba i); loop (i+step)) in loop 0
diff --git a/latex-parse/src/arena.ml b/latex-parse/src/arena.ml
new file mode 100644
index 0000000..71a95e1
--- /dev/null
+++ b/latex-parse/src/arena.ml
@@ -0,0 +1,21 @@
+open Bigarray
+type kinds_t = (int32, int32_elt, c_layout) Array1.t
+type offs_t  = (int32, int32_elt, c_layout) Array1.t
+type codes_t = (int32, int32_elt, c_layout) Array1.t
+type issues_t= (int32, int32_elt, c_layout) Array1.t
+
+type buffers = { kinds:kinds_t; offs:offs_t; codes:codes_t; issues:issues_t; mutable next_ix:int }
+type t = { a:buffers; b:buffers; mutable current:buffers; cap:int }
+
+let create_buffers cap =
+  let mk () = Array1.create Int32 c_layout cap in
+  { kinds=mk (); offs=mk (); codes=mk (); issues=mk (); next_ix=0 }
+
+let create ~cap =
+  let a = create_buffers cap and b = create_buffers cap in
+  { a; b; current=a; cap }
+
+let swap t = t.current <- (if t.current==t.a then t.b else t.a); t.current.next_ix <- 0
+let current t = t.current
diff --git a/latex-parse/src/ipc.ml b/latex-parse/src/ipc.ml
new file mode 100644
index 0000000..0d1c0f6
--- /dev/null
+++ b/latex-parse/src/ipc.ml
@@ -0,0 +1,117 @@
+type msg_ty = Req | Resp | Cancel
+let ty_to_u32 = function Req->1 | Resp->2 | Cancel->3
+let u32_to_ty = function 1l->Req | 2l->Resp | 3l->Cancel | _->failwith "bad ty"
+type header = { ty:msg_ty; req_id:int64; len:int }
+let header_bytes = 16
+
+let be32_put b off v =
+  Bytes.set b off     (Char.chr ((v lsr 24) land 0xFF));
+  Bytes.set b (off+1) (Char.chr ((v lsr 16) land 0xFF));
+  Bytes.set b (off+2) (Char.chr ((v lsr  8) land 0xFF));
+  Bytes.set b (off+3) (Char.chr ( v        land 0xFF))
+let be32_get b off =
+  ((Char.code (Bytes.get b off)) lsl 24)
+  lor ((Char.code (Bytes.get b (off+1))) lsl 16)
+  lor ((Char.code (Bytes.get b (off+2))) lsl 8)
+  lor (Char.code (Bytes.get b (off+3)))
+
+let be64_put b off v =
+  let open Int64 in
+  Bytes.set b (off+0) (Char.chr (to_int (shift_right_logical v 56)));
+  Bytes.set b (off+1) (Char.chr (to_int (shift_right_logical v 48)));
+  Bytes.set b (off+2) (Char.chr (to_int (shift_right_logical v 40)));
+  Bytes.set b (off+3) (Char.chr (to_int (shift_right_logical v 32)));
+  Bytes.set b (off+4) (Char.chr (to_int (shift_right_logical v 24)));
+  Bytes.set b (off+5) (Char.chr (to_int (shift_right_logical v 16)));
+  Bytes.set b (off+6) (Char.chr (to_int (shift_right_logical v  8)));
+  Bytes.set b (off+7) (Char.chr (to_int v))
+
+let rec write_all fd b o l =
+  if l=0 then () else
+  let n = Unix.write fd b o l in
+  if n=0 then failwith "short write" else write_all fd b (o+n) (l-n)
+
+let rec read_exact fd b o l =
+  if l=0 then () else
+  let n = Unix.read fd b o l in
+  if n=0 then failwith "eof" else read_exact fd b (o+n) (l-n)
+
+let write_header fd (h:header) =
+  let b = Bytes.create header_bytes in
+  be32_put b 0 (ty_to_u32 h.ty); be64_put b 4 h.req_id; be32_put b 12 h.len;
+  write_all fd b 0 header_bytes
+
+let read_header fd : header option =
+  let b = Bytes.create header_bytes in
+  try
+    read_exact fd b 0 header_bytes;
+    let ty = u32_to_ty (Int32.of_int (be32_get b 0)) in
+    let open Int64 in
+    let id =
+      logor (shift_left (of_int (Char.code (Bytes.get b 4))) 56)
+      (logor (shift_left (of_int (Char.code (Bytes.get b 5))) 48)
+      (logor (shift_left (of_int (Char.code (Bytes.get b 6))) 40)
+      (logor (shift_left (of_int (Char.code (Bytes.get b 7))) 32)
+      (logor (shift_left (of_int (Char.code (Bytes.get b 8))) 24)
+      (logor (shift_left (of_int (Char.code (Bytes.get b 9))) 16)
+      (logor (shift_left (of_int (Char.code (Bytes.get b 10))) 8)
+             (of_int (Char.code (Bytes.get b 11))))))))) in
+    Some { ty; req_id=id; len=be32_get b 12 }
+  with _ -> None
+
+let write_req fd ~req_id ~(bytes:bytes) =
+  let len = 4 + Bytes.length bytes in
+  let p = Bytes.create len in
+  be32_put p 0 (Bytes.length bytes); Bytes.blit bytes 0 p 4 (Bytes.length bytes);
+  write_header fd { ty=Req; req_id; len }; write_all fd p 0 len
+
+let write_resp fd ~req_id ~status ~n_tokens ~issues_len ~alloc_mb10 ~major_cycles =
+  let p = Bytes.create 20 in
+  be32_put p 0 status; be32_put p 4 n_tokens; be32_put p 8 issues_len;
+  be32_put p 12 alloc_mb10; be32_put p 16 major_cycles;
+  write_header fd { ty=Resp; req_id; len=20 }; write_all fd p 0 20
+
+let write_cancel fd ~req_id = write_header fd { ty=Cancel; req_id; len=0 }
+
+type any =
+  | Any_req of int64 * bytes
+  | Any_resp of int64 * int * int * int * int * int
+  | Any_cancel of int64
+  | Any_hup
+
+let read_any fd =
+  match read_header fd with
+  | None -> Any_hup
+  | Some h ->
+    begin match h.ty with
+    | Req ->
+        let p = Bytes.create h.len in read_exact fd p 0 h.len;
+        let ilen = be32_get p 0 in
+        Any_req (h.req_id, Bytes.sub p 4 ilen)
+    | Resp ->
+        let p = Bytes.create h.len in read_exact fd p 0 h.len in
+        let g off = be32_get p off in
+        Any_resp (h.req_id, g 0, g 4, g 8, g 12, g 16)
+    | Cancel -> Any_cancel h.req_id
+    end
diff --git a/latex-parse/src/worker.ml b/latex-parse/src/worker.ml
new file mode 100644
index 0000000..35077b6
--- /dev/null
+++ b/latex-parse/src/worker.ml
@@ -0,0 +1,122 @@
+open Ipc
+
+type stats = { mutable major_cycles : int }
+let stats = { major_cycles = 0 }
+
+type state = {
+  fd        : Unix.file_descr;
+  arenas    : Arena.t;
+  mutable ibuf     : bytes;  (* reusable input buffer *)
+  mutable ibuf_cap : int;
+  mutable cur_req  : int64 option;
+  mutable cancelled: bool;
+  mutable reqs     : int;
+  mutable words_at_spawn  : float;
+  mutable majors_at_spawn : int;
+}
+
+let live_words ()  = (Gc.quick_stat ()).live_words
+let words_total () = let s = Gc.quick_stat () in s.minor_words +. s.major_words
+let major_collections () = (Gc.stat ()).major_collections
+
+let reset_spawn_counters st =
+  st.words_at_spawn  <- words_total ();
+  st.majors_at_spawn <- major_collections ()
+
+let alloc_mb_since_spawn st =
+  let words = (words_total ()) -. st.words_at_spawn in
+  words *. (float Sys.word_size /. 8.0) /. 1.048_576
+
+let majors_since_spawn st =
+  (major_collections ()) - st.majors_at_spawn
+
+let should_retire st =
+  alloc_mb_since_spawn st >= float Config.worker_alloc_budget_mb
+  || majors_since_spawn st >= Config.worker_major_cycles_budget
+
+let ensure_ibuf st need =
+  if need <= st.ibuf_cap then () else
+    let cap = max need (max 1 st.ibuf_cap * 2) in
+    st.ibuf <- Bytes.create cap; st.ibuf_cap <- cap
+
+let _alarm = Gc.create_alarm (fun () -> stats.major_cycles <- stats.major_cycles + 1)
+
+let update_and_log st =
+  st.reqs <- st.reqs + 1;
+  if st.reqs mod 1000 = 0 then begin
+    let rss = Meminfo.rss_mb () in
+    let live_mb = (live_words () *. float Sys.word_size /. 8.0) /. 1.0e6 in
+    let alloc_mb = alloc_mb_since_spawn st in
+    let majors   = majors_since_spawn st in
+    Printf.eprintf "[worker] req=%d rss=%.1fMB live=%.1fMB alloc_since=%.0fMB majors_since=%d\n%!"
+      st.reqs rss live_mb alloc_mb majors
+  end
+
+let handle_req st ~req_id (input:bytes) =
+  st.cur_req <- Some req_id; st.cancelled <- false;
+  Gc_prep.prepay ();
+  Arena.swap st.arenas;
+  let cur = Arena.current st.arenas in
+  Pretouch.pre_touch_bytes input ~page:Config.page_bytes;
+  let est_tokens = int_of_float (1.30 *. float (Bytes.length input)) in
+  Pretouch.pre_touch_ba_1 cur.Arena.kinds  ~elem_bytes:4 ~elems:est_tokens ~page:Config.page_bytes;
+  Pretouch.pre_touch_ba_1 cur.Arena.codes  ~elem_bytes:4 ~elems:est_tokens ~page:Config.page_bytes;
+  Pretouch.pre_touch_ba_1 cur.Arena.offs   ~elem_bytes:4 ~elems:est_tokens ~page:Config.page_bytes;
+  Pretouch.pre_touch_ba_1 cur.Arena.issues ~elem_bytes:4 ~elems:1024        ~page:Config.page_bytes;
+  (match Sys.getenv_opt "L0_FAULT_MS" with
+   | Some s -> let d = try int_of_string s with _ -> 0 in if d>0 && (Random.bits () land 1023 = 0)
+               then Unix.sleepf (float d /. 1000.)
+   | None -> ());
+  let (status, n_tokens, issues_len) = Real_processor.run input cur in
+  let s = Gc.quick_stat () in
+  let words = s.minor_words +. s.major_words in
+  let bytes = words *. (float Sys.word_size /. 8.0) in
+  let alloc_mb10 = int_of_float (10.0 *. (bytes /. 1.048_576)) in
+  let majors = majors_since_spawn st in
+  (match st.cur_req with
+   | Some id when not st.cancelled ->
+       Ipc.write_resp st.fd ~req_id:id ~status ~n_tokens ~issues_len ~alloc_mb10 ~major_cycles:majors
+   | _ -> ());
+  st.cur_req <- None; st.cancelled <- false;
+  update_and_log st;
+  if should_retire st then exit 0 else ()
+
+let start_loop fd ~core =
+  Mlock.init (); Gc_prep.init_gc ();
+  let st = {
+    fd; arenas = Arena.create ~cap:Config.arenas_tokens_cap;
+    ibuf=Bytes.create 0; ibuf_cap=0; cur_req=None; cancelled=false; reqs=0;
+    words_at_spawn=0.0; majors_at_spawn=0;
+  } in
+  reset_spawn_counters st;
+  let rec loop () =
+    match Ipc.read_any st.fd with
+    | Any_req (id, payload) ->
+        ensure_ibuf st (Bytes.length payload);
+        Bytes.blit payload 0 st.ibuf 0 (Bytes.length payload);
+        let view = Bytes.sub st.ibuf 0 (Bytes.length payload) in
+        handle_req st ~req_id:id view; loop ()
+    | Any_cancel id ->
+        (match st.cur_req with Some cur when cur = id -> st.cancelled <- true | _ -> ());
+        loop ()
+    | Any_resp _ -> loop ()
+    | Any_hup -> exit 0
+  in loop ()
diff --git a/latex-parse/src/broker.ml b/latex-parse/src/broker.ml
new file mode 100644
index 0000000..f6d6d2f
--- /dev/null
+++ b/latex-parse/src/broker.ml
@@ -0,0 +1,219 @@
+open Ipc
+open Clock
+
+type wstate = Hot | Cooling
+type worker = {
+  mutable fd       : Unix.file_descr;
+  mutable pid      : int;
+  core             : int;
+  mutable state    : wstate;
+  mutable inflight : bool;
+  mutable alloc_mb : float;
+  mutable major    : int;
+}
+
+let spawn_worker ~core =
+  let sv, sc = Unix.socketpair Unix.PF_UNIX Unix.SOCK_STREAM 0 in
+  Unix.set_close_on_exec sv; Unix.set_close_on_exec sc;
+  match Unix.fork () with
+  | 0 -> Unix.close sv; Worker.start_loop sc ~core; exit 0
+  | pid ->
+      Unix.close sc; Unix.clear_nonblock sv;
+      { fd=sv; pid; core; state=Hot; inflight=false; alloc_mb=0.0; major=0 }
+
+type pool = {
+  workers: worker array;
+  mutable rr: int;
+  timer: Hedge_timer.t;
+  mutable requests: int;
+  mutable hedge_fired: int;
+  mutable hedge_wins: int;
+  mutable rotations: int;
+}
+
+let init_pool cores =
+  { workers = Array.mapi (fun _ c -> spawn_worker ~core:c) cores;
+    rr=0; timer=Hedge_timer.create ();
+    requests=0; hedge_fired=0; hedge_wins=0; rotations=0; }
+
+let pick_hot p =
+  let n = Array.length p.workers in
+  let rec go i k =
+    if k>=n then p.workers.(i mod n) else
+    let w = p.workers.(i mod n) in
+    if w.state=Hot && not w.inflight then (p.rr <- i+1; w)
+    else go (i+1) (k+1)
+  in go p.rr 0
+
+let pick_secondary p primary =
+  let n = Array.length p.workers in
+  let rec go i k =
+    if k>=n then primary else
+    let w = p.workers.(i mod n) in
+    if w != primary && w.state=Hot && not w.inflight then w else go (i+1) (k+1)
+  in go p.rr 1
+
+let update_on_resp p w ~alloc_mb10 ~major =
+  w.inflight <- false;
+  w.alloc_mb <- float alloc_mb10 /. 10.0;
+  w.major    <- major;
+  if (w.alloc_mb >= float Config.worker_alloc_budget_mb ||
+      w.major    >= Config.worker_major_cycles_budget) && w.state=Hot
+  then w.state <- Cooling
+
+let maybe_rotate p w =
+  if w.state=Cooling && not w.inflight then (
+    (try Unix.close w.fd with _->());
+    (try ignore (Unix.waitpid [] w.pid) with _->());
+    let nw = spawn_worker ~core:w.core in
+    w.fd <- nw.fd; w.pid <- nw.pid; w.state <- Hot; w.inflight <- false;
+    w.alloc_mb <- 0.0; w.major <- 0; p.rotations <- p.rotations + 1
+  )
+
+let inflight_total p =
+  Array.fold_left (fun acc w -> acc + (if w.inflight then 1 else 0)) 0 p.workers
+
+let int_of_fd (fd:Unix.file_descr) : int = (Obj.magic fd : int)
+
+let find_by_fd p fd =
+  let rec loop i =
+    if i = Array.length p.workers then None
+    else
+      let w = p.workers.(i) in
+      if int_of_fd w.fd = fd then Some w else loop (i+1)
+  in loop 0
+
+let req_ctr = ref 0L
+let next_req_id () = let id = !req_ctr in req_ctr := Int64.succ id; id
+
+let drain_one_ready ~deadline_ns p =
+  let fd1 =
+    if p.workers.(0).inflight then int_of_fd p.workers.(0).fd else -1 in
+  let fd2 =
+    if p.workers.(1).inflight then int_of_fd p.workers.(1).fd else -1 in
+  if fd1 < 0 && fd2 < 0 then () else begin
+    let tf, ready = Hedge_timer.wait_two p.timer ~fd1 ~fd2 in
+    ignore tf;
+    if ready >= 0 then
+      match find_by_fd p (Obj.magic ready) with
+      | None -> ()
+      | Some w ->
+          begin match Ipc.read_any w.fd with
+          | Any_resp (_rid, _st, _nt, _iss, mb10, maj) ->
+              update_on_resp p w ~alloc_mb10:mb10 ~major:maj; maybe_rotate p w
+          | Any_hup ->
+              w.inflight <- false; maybe_rotate p w
+          | _ -> ()
+          end
+    else ()
+  end;
+  if Int64.sub (Clock.now ()) deadline_ns > 0L then
+    failwith "Backpressure timeout: workers stuck inflight"
+
+type svc_result = { status:int; n_tokens:int; issues_len:int; origin:[`P|`H] }
+
+let rescue_once p ~req_id ~(input:bytes) : svc_result =
+  Array.iter (maybe_rotate p) p.workers;
+  let w = pick_hot p in
+  w.inflight <- true;
+  Ipc.write_req w.fd ~req_id ~bytes:input;
+  match Ipc.read_any w.fd with
+  | Any_resp (rid, st, nt, iss, mb10, maj) when rid=req_id ->
+      update_on_resp p w ~alloc_mb10:mb10 ~major:maj; maybe_rotate p w;
+      { status=st; n_tokens=nt; issues_len=iss; origin=`P }
+  | Any_hup ->
+      w.inflight <- false; maybe_rotate p w;
+      failwith "broker: rescue failed (HUP)"
+  | _ -> failwith "broker: rescue unexpected"
+
+let hedged_call p ~(input:bytes) ~(hedge_ms:int) : svc_result =
+  let deadline = Int64.add (Clock.now ()) (Clock.ns_of_ms 30_000) in
+  while inflight_total p >= Array.length p.workers do
+    drain_one_ready ~deadline_ns:deadline p
+  done;
+
+  let req_id  = next_req_id () in
+  let primary = pick_hot p in
+  primary.inflight <- true;
+  Ipc.write_req primary.fd ~req_id ~bytes:input;
+
+  Hedge_timer.arm p.timer ~ns:(Clock.ns_of_ms hedge_ms);
+  p.requests <- p.requests + 1;
+
+  let rec wait_primary_or_timer () =
+    let tf, ready = Hedge_timer.wait_two p.timer
+        ~fd1:(int_of_fd primary.fd) ~fd2:(-1)
+    in
+    if ready = int_of_fd primary.fd then `Primary_ready
+    else if tf = 1 then `Hedge_fire else wait_primary_or_timer ()
+  in
+
+  match wait_primary_or_timer () with
+  | `Primary_ready ->
+      begin match Ipc.read_any primary.fd with
+      | Any_resp (rid, st, nt, iss, mb10, maj) when rid=req_id ->
+          update_on_resp p primary ~alloc_mb10:mb10 ~major:maj; maybe_rotate p primary;
+          { status=st; n_tokens=nt; issues_len=iss; origin=`P }
+      | Any_hup ->
+          primary.inflight <- false; maybe_rotate p primary;
+          let sec = pick_secondary p primary in
+          sec.inflight <- true; Ipc.write_req sec.fd ~req_id ~bytes:input;
+          begin match Ipc.read_any sec.fd with
+          | Any_resp (rid, st, nt, iss, mb10, maj) when rid=req_id ->
+              update_on_resp p sec ~alloc_mb10:mb10 ~major:maj; maybe_rotate p sec;
+              { status=st; n_tokens=nt; issues_len=iss; origin=`H }
+          | Any_hup ->
+              sec.inflight <- false; maybe_rotate p sec;
+              rescue_once p ~req_id ~input
+          | _ -> rescue_once p ~req_id ~input
+          end
+      | _ -> rescue_once p ~req_id ~input
+      end
+
+  | `Hedge_fire ->
+      p.hedge_fired <- p.hedge_fired + 1;
+      let sec = pick_secondary p primary in
+      sec.inflight <- true; Ipc.write_req sec.fd ~req_id ~bytes:input;
+      let rec race () =
+        let _tf, ready = Hedge_timer.wait_two p.timer
+            ~fd1:(int_of_fd primary.fd) ~fd2:(int_of_fd sec.fd) in
+        if ready = int_of_fd primary.fd then
+          begin match Ipc.read_any primary.fd with
+          | Any_resp (rid, st, nt, iss, mb10, maj) when rid=req_id ->
+              update_on_resp p primary ~alloc_mb10:mb10 ~major:maj; maybe_rotate p primary;
+              Ipc.write_cancel sec.fd ~req_id; sec.inflight <- false;
+              { status=st; n_tokens=nt; issues_len=iss; origin=`P }
+          | Any_hup ->
+              primary.inflight <- false; maybe_rotate p primary; race ()
+          | _ -> race ()
+          end
+        else if ready = int_of_fd sec.fd then
+          begin match Ipc.read_any sec.fd with
+          | Any_resp (rid, st, nt, iss, mb10, maj) when rid=req_id ->
+              update_on_resp p sec ~alloc_mb10:mb10 ~major:maj; maybe_rotate p sec;
+              Ipc.write_cancel primary.fd ~req_id; primary.inflight <- false;
+              p.hedge_wins <- p.hedge_wins + 1;
+              { status=st; n_tokens=nt; issues_len=iss; origin=`H }
+          | Any_hup ->
+              sec.inflight <- false; maybe_rotate p sec; race ()
+          | _ -> race ()
+          end
+        else race ()
+      in race ()
diff --git a/latex-parse/src/service_bracket.ml b/latex-parse/src/service_bracket.ml
new file mode 100644
index 0000000..f8b3a86
--- /dev/null
+++ b/latex-parse/src/service_bracket.ml
@@ -0,0 +1,26 @@
+open Clock
+type stamps = {
+  mutable t_in_start    : int64;
+  mutable t_in_done     : int64;
+  mutable t_proc_start  : int64;
+  mutable t_hedge_fire  : int64;
+  mutable t_first_reply : int64;
+  mutable t_reply_ready : int64;
+}
+let make () = { t_in_start=0L; t_in_done=0L; t_proc_start=0L; t_hedge_fire=0L; t_first_reply=0L; t_reply_ready=0L }
+
+let measure_bytes_in_to_reply_ready ~(recv: unit -> bytes) ~(process: bytes -> 'r) ~(format:'r -> bytes) ~(send:bytes -> unit) =
+  let st = make () in
+  st.t_in_start <- Clock.now ();
+  let req = recv () in
+  st.t_in_done <- Clock.now (); st.t_proc_start <- st.t_in_done;
+  let res = process req in
+  let reply = format res in
+  st.t_reply_ready <- Clock.now ();
+  send reply;
+  (Clock.ms_of_ns Int64.(sub st.t_reply_ready st.t_in_start), st)
diff --git a/latex-parse/src/main_service.ml b/latex-parse/src/main_service.ml
new file mode 100644
index 0000000..687288a
--- /dev/null
+++ b/latex-parse/src/main_service.ml
@@ -0,0 +1,122 @@
+open Unix
+
+let unlink_if_exists p = try Unix.unlink p with _ -> ()
+let rec read_exact fd b o l = if l=0 then () else let n=Unix.read fd b o l in if n=0 then failwith "client eof" else read_exact fd b (o+n) (l-n)
+let rec write_all fd b o l = if l=0 then () else let n=Unix.write fd b o l in if n=0 then failwith "short write" else write_all fd b (o+n) (l-n)
+
+let () = Sys.set_signal Sys.sigpipe Sys.Signal_ignore
+
+let sigchld_reaper _ =
+  let rec reap () =
+    match Unix.waitpid [Unix.WNOHANG] (-1) with
+    | 0, _ -> ()
+    | _, _ -> reap ()
+  in
+  (try reap () with _ -> ())
+
+let run () =
+  Sys.set_signal Sys.sigchld (Sys.Signal_handle sigchld_reaper);
+  let sock_path = Config.service_sock_path in
+  unlink_if_exists sock_path;
+  let srv = Unix.socket PF_UNIX SOCK_STREAM 0 in
+  Unix.set_close_on_exec srv;
+  Unix.bind srv (ADDR_UNIX sock_path); Unix.listen srv 64;
+  prerr_endline ("[svc] listening at "^sock_path);
+
+  let pool = Broker.init_pool Config.pool_cores in
+
+  let tail_csv_keep = Config.tail_trace_keep in
+  let slow = ref ([] : (float * (int64*int64*int64*int64*int64*int64*bool*string)) list) in
+  let add_slowest ms row =
+    let xs = (ms, row) :: !slow in
+    let xs = List.sort (fun (a,_) (b,_) -> compare b a) xs in
+    let rec take n = function []->[] | _ when n=0 -> [] | y::ys -> y::take (n-1) ys in
+    slow := take tail_csv_keep xs
+  in
+  let dump_csv () =
+    let oc = open_out Config.tail_csv_path in
+    output_string oc "ms_total,t_in_start,t_in_done,t_proc_start,t_hedge_fire,t_first_reply,t_reply_ready,hedged,origin\n";
+    List.iter (fun (ms,(a,b,c,d,e,f,h,origin)) ->
+      Printf.fprintf oc "%.3f,%Ld,%Ld,%Ld,%Ld,%Ld,%Ld,%d,%s\n" ms a b c d e f (if h then 1 else 0) origin
+    ) (List.rev !slow);
+    close_out oc
+  in
+
+  let rec accept_loop () =
+    let (c,_) = Unix.accept srv in
+
+    let recv () =
+      let hdr = Bytes.create 4 in
+      read_exact c hdr 0 4;
+      let len =
+        ((Char.code (Bytes.get hdr 0)) lsl 24)
+        lor ((Char.code (Bytes.get hdr 1)) lsl 16)
+        lor ((Char.code (Bytes.get hdr 2)) lsl 8)
+        lor (Char.code (Bytes.get hdr 3))
+      in
+      if len > Config.max_req_bytes then failwith "req too large";
+      let b = Bytes.create len in read_exact c b 0 len; b
+    in
+
+    let process req =
+      try
+        `Ok (Broker.hedged_call pool ~input:req ~hedge_ms:Config.hedge_timer_ms_default)
+      with _exn ->
+        `Err
+    in
+
+    let format = function
+      | `Ok r ->
+          let b = Bytes.create 13 in
+          let put32 off v =
+            Bytes.set b off     (Char.chr ((v lsr 24) land 0xFF));
+            Bytes.set b (off+1) (Char.chr ((v lsr 16) land 0xFF));
+            Bytes.set b (off+2) (Char.chr ((v lsr  8) land 0xFF));
+            Bytes.set b (off+3) (Char.chr ( v        land 0xFF))
+          in
+          put32 0 r.status; put32 4 r.n_tokens; put32 8 r.issues_len;
+          Bytes.set b 12 (match r.origin with `P->'\001' | `H->'\002'); b
+      | `Err ->
+          let b = Bytes.create 13 in
+          let put32 off v =
+            Bytes.set b off     (Char.chr ((v lsr 24) land 0xFF));
+            Bytes.set b (off+1) (Char.chr ((v lsr 16) land 0xFF));
+            Bytes.set b (off+2) (Char.chr ((v lsr  8) land 0xFF));
+            Bytes.set b (off+3) (Char.chr ( v        land 0xFF))
+          in
+          put32 0 1; put32 4 0; put32 8 0; Bytes.set b 12 '\000'; b
+    in
+
+    let send reply =
+      let len = Bytes.length reply in
+      let hdr = Bytes.create 4 in
+      Bytes.set hdr 0 (Char.chr ((len lsr 24) land 0xFF));
+      Bytes.set hdr 1 (Char.chr ((len lsr 16) land 0xFF));
+      Bytes.set hdr 2 (Char.chr ((len lsr  8) land 0xFF));
+      Bytes.set hdr 3 (Char.chr ( len        land 0xFF));
+      write_all c hdr 0 4; write_all c reply 0 len
+    in
+
+    let (ms, st) = Service_bracket.measure_bytes_in_to_reply_ready ~recv ~process ~format ~send in
+    let hedged = false in
+    add_slowest ms (st.Service_bracket.t_in_start, st.t_in_done, st.t_proc_start, st.t_hedge_fire, st.t_first_reply, st.t_reply_ready, hedged, "");
+    if Broker.(pool.requests mod 10_000 = 0) then begin
+      Printf.eprintf "[hedge] req=%d fired=%d (%.3f%%) wins=%d (%.1f%%) rotations=%d\n%!"
+        Broker.(pool.requests) Broker.(pool.hedge_fired)
+        (100.0 *. float Broker.(pool.hedge_fired) /. float (max 1 Broker.(pool.requests)))
+        Broker.(pool.hedge_wins)
+        (100.0 *. float Broker.(pool.hedge_wins) /. float (max 1 Broker.(pool.hedge_fired)))
+        Broker.(pool.rotations);
+      dump_csv ()
+    end;
+    Unix.close c; accept_loop ()
+  in
+  accept_loop ()
+
+let () = run ()
diff --git a/latex-parse/bench/percentiles_strict.ml b/latex-parse/bench/percentiles_strict.ml
new file mode 100644
index 0000000..e667c56
--- /dev/null
+++ b/latex-parse/bench/percentiles_strict.ml
@@ -0,0 +1,12 @@
+let exact_with_index (arr: float array) (q: float) =
+  let n = Array.length arr in
+  if n=0 then invalid_arg "empty";
+  let a = Array.copy arr in
+  Array.sort compare a;
+  let idx = max 0 (min (n-1) (int_of_float (ceil (float n *. q)) - 1)) in
+  (idx, a.(idx))
+
+let dump name samples =
+  let n = Array.length samples in
+  let pr q = let (idx, v) = exact_with_index samples q in
+    Printf.printf "%s P%.3f idx=%d/%d val=%.3f ms\n%!" name (100.0*.q) idx n v in
+  pr 0.50; pr 0.90; pr 0.95; pr 0.99; if n>=100_000 then pr 0.999
diff --git a/latex-parse/bench/run_service_bench_concurrent.ml b/latex-parse/bench/run_service_bench_concurrent.ml
new file mode 100644
index 0000000..8e1dfb5
--- /dev/null
+++ b/latex-parse/bench/run_service_bench_concurrent.ml
@@ -0,0 +1,57 @@
+open Unix
+open Percentiles_strict
+
+let read_file path =
+  let ic = open_in_bin path in let len = in_channel_length ic in
+  let s = really_input_string ic len in close_in ic; Bytes.unsafe_of_string s
+
+let rec write_all fd b o l =
+  if l=0 then () else let n=Unix.write fd b o l in if n=0 then failwith "short write" else write_all fd b (o+n) (l-n)
+let rec read_exact fd b o l =
+  if l=0 then () else let n=Unix.read fd b o l in if n=0 then failwith "eof" else read_exact fd b (o+n) (l-n)
+
+let send_once payload =
+  let c = Unix.socket PF_UNIX SOCK_STREAM 0 in
+  Unix.connect c (ADDR_UNIX Config.service_sock_path);
+  let len = Bytes.length payload in
+  let hdr = Bytes.create 4 in
+  Bytes.set hdr 0 (Char.chr ((len lsr 24) land 0xFF));
+  Bytes.set hdr 1 (Char.chr ((len lsr 16) land 0xFF));
+  Bytes.set hdr 2 (Char.chr ((len lsr  8) land 0xFF));
+  Bytes.set hdr 3 (Char.chr ( len        land 0xFF));
+  let t0 = Clock.now () in
+  write_all c hdr 0 4; write_all c payload 0 len;
+  let rhdr = Bytes.create 4 in read_exact c rhdr 0 4;
+  let rlen =
+    ((Char.code (Bytes.get rhdr 0)) lsl 24)
+    lor ((Char.code (Bytes.get rhdr 1)) lsl 16)
+    lor ((Char.code (Bytes.get rhdr 2)) lsl 8)
+    lor (Char.code (Bytes.get rhdr 3))
+  in
+  let rb = Bytes.create rlen in read_exact c rb 0 rlen;
+  Unix.close c;
+  Clock.ms_of_ns Int64.(sub (Clock.now ()) t0)
+
+let () =
+  if Array.length Sys.argv < 4 then (prerr_endline "usage: run_service_bench_concurrent FILE ITERS THREADS"; exit 2);
+  let file = Sys.argv.(1) in
+  let total = int_of_string Sys.argv.(2) in
+  let threads = int_of_string Sys.argv.(3) in
+  let payload = read_file file in
+  let samples = Array.make total 0.0 in
+  let idx = ref 0 in
+  let m = Mutex.create () in
+  let worker () =
+    while true do
+      Mutex.lock m;
+      if !idx >= total then (Mutex.unlock m; Thread.exit ());
+      let i = !idx in incr idx; Mutex.unlock m;
+      samples.(i) <- send_once payload
+    done
+  in
+  let ths = Array.init threads (fun _ -> Thread.create worker ()) in
+  Array.iter Thread.join ths;
+  Printf.printf "RTT N=%d\n%!" total;
+  Percentiles_strict.dump "RTT" samples
diff --git a/latex-parse/bench/ipc_propcheck.ml b/latex-parse/bench/ipc_propcheck.ml
new file mode 100644
index 0000000..a24a9a2
--- /dev/null
+++ b/latex-parse/bench/ipc_propcheck.ml
@@ -0,0 +1,37 @@
+open Ipc
+
+let rand_buf n =
+  let b = Bytes.create n in
+  for i=0 to n-1 do Bytes.set b i (Char.chr (Random.int 256)) done; b
+
+let roundtrip_once () =
+  let sv, sc = Unix.socketpair Unix.PF_UNIX Unix.SOCK_STREAM 0 in
+  match Unix.fork () with
+  | 0 ->
+      Unix.close sv;
+      let rec loop () =
+        match read_any sc with
+        | Any_req (id, payload) ->
+            write_resp sc ~req_id:id ~status:0 ~n_tokens:(Bytes.length payload)
+              ~issues_len:0 ~alloc_mb10:0 ~major_cycles:0; loop ()
+        | Any_hup -> exit 0
+        | _ -> loop ()
+      in loop ()
+  | pid ->
+      Unix.close sc;
+      for _=1 to 1000 do
+        let len = (Random.int 65536) in
+        let p = rand_buf len in
+        let id = Int64.of_int (Random.bits ()) in
+        write_req sv ~req_id:id ~bytes:p;
+        match read_any sv with
+        | Any_resp (rid, _st, nt, _iss, _mb, _maj) when rid=id && nt=Bytes.length p -> ()
+        | _ -> failwith "IPC roundtrip mismatch"
+      done;
+      Unix.close sv; ignore (Unix.waitpid [] pid)
+
+let () =
+  Random.init 42; for _=1 to 100 do roundtrip_once () done;
+  print_endline "IPC property check: OK"
diff --git a/latex-parse/bench/time_selftest.ml b/latex-parse/bench/time_selftest.ml
new file mode 100644
index 0000000..1cdb134
--- /dev/null
+++ b/latex-parse/bench/time_selftest.ml
@@ -0,0 +1,6 @@
+open Clock
+let () =
+  let t0 = now () in Unix.sleepf 0.010; let t1 = now () in
+  let dt_ms = ms_of_ns Int64.(sub t1 t0) in
+  Printf.printf "Sleep(10ms) measured = %.3f ms\n%!" dt_ms;
+  assert (dt_ms > 7.0 && dt_ms < 30.0); print_endline "OK"