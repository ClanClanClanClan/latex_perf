# planner_v25_full.yaml
# SHA256 of original source (UTF-8, without these YAML headers):
#   6f25b260eec9f1974c6b2e2d7e2c1f127cb4b1b4fc9d823497da1a029f9873d1
---
metadata:
  title: "LaTeX Perfectionist v25 – 3-Year Solo-Developer Master Plan"
  subtitle: "Comprehensive, formally-verified, 623-rule release"
  version: "v25-0.1-draft"
  author: "Solo Dev ‹your-handle›"
  last_update_utc: "2025-07-27"
  target_release: "2028-08-01"
global_table_of_contents:
  - "1. Executive Overview & Success Criteria"
  - "2. Governance, Workflow & Risk Register"
  - "3. L0-L1 Infrastructure (Lexer + Expander)"
  - "4. L2 AST Parser & Structural Engine"
  - "5. L3 Semantic Interpreter & Incremental Core"
  - "6. L4 Style Layer & Natural-Language Analytics"
  - "7. Validator Generation & Automation Fabric"
  - "8. Performance Engineering & Systems Optimisation"
  - "9. Quality Assurance, Telemetry, Tooling, CI/CD"
  - "10. Documentation, Packaging & Release Engineering"
  - "11. Appendices (Corpus spec, Code-style, Proof tactics, etc.)"

sections:
  - id: 1
    title: "Executive Overview & Success Criteria"
    body: |-
      1  Executive Overview & Success Criteria

      1.1  Vision Statement

      “Instant, provably-correct feedback on any LaTeX source—within 1 ms per keystroke, across 21 languages, with <0.1 % false positives.”

      1.2  Key Numbers

      | Metric                               | Baseline (v24-R3) | Target (v25) |
      |--------------------------------------|-------------------|--------------|
      | Validators implemented               | 80 / 612          | 623 / 623    |
      | Processing latency (10 k lines, hot) | 420 ms            | < 42 ms      |
      | Formal-proof admits                  | 211               | 0            |
      | Supported languages                  | 3                 | 21           |
      | False-positive rate                  | 3.2 %             | ≤ 0.1 %      |

      1.3  Three-Phase Trajectory

      | Year | Thematic Goal | Cumulative Validators| New Tech |
      |------|---------------|----------------------|----------|
      | Y1 | Foundation – infrastructure, formal proofs, 180 validators | 180 | DSL + Proof Library |
      | Y2 | Acceleration – pattern mining & family generation | 430 | Pattern-miner v1 |
      | Y3 | Completion – ML-assisted generation, polish | 623 | ML-generator v2 |

      1.4  Critical Success Factors
        1. Infrastructure First – 6-month up-front tool-building prevents 24 months toil.
        2. Pattern Families – 80 % of rules stem from 20 % of patterns; validate the families, not leaf nodes.
        3. Formal Proof Automation – shared tactics slash manual Coq overhead by 90 %.
        4. Incremental Everything – lexer→parser→semantics all restart-free on keystroke.
        5. Corpus-Driven – 2 846 curated papers become perpetual regression bed.

      1.5  Deliverable Definition of Done
        • D1 Validator coverage = 623 implemented, all unit/prop tests green.  
        • D2 `make proofs` returns **QED** (0 admits) in ≤ 6 min on laptop.  
        • D3 End-to-end latency < 42 ms (99ᵗʰ percentile) on 50 k-line doc.  
        • D4 False-positive rate ≤ 0.1 % on entire corpus + fuzz suite.  
        • D5 Comprehensive docs: tutorial, API, proof manual, ops playbook.

  - id: 2
    title: "Governance, Workflow & Risk Register"
    body: |-
      2  Governance, Workflow & Risk Register

      2.1  Solo-Developer Operating Model

      | Discipline       | Tooling                             | Cadence                         | Output                       |
      |------------------|-------------------------------------|---------------------------------|------------------------------|
      | Product planning | **Planner.md** (this doc)           | Quarterly                       | Updated roadmap              |
      | Issue tracking   | GitHub Projects v2 (kanban)         | Daily                           | T-shirt-sized tickets        |
      | Code hosting     | private GitHub; mirror on SourceHut | Continuous                      | branches = `topic/<feature>` |
      | Proof review     | Coq CI + coq-ci-diff                | Per commit                      | proof delta report           |
      | Perf benchmark   | Criterion + hyperfine               | Nightly                         | trend charts                 |
      | Release cuts     | GitHub Actions matrix               | Monthly (nightlies) & tagged GA | signed artefacts             |

      2.2  Branch & Release Strategy

      ```
      main ──╮───────────▶ v25.0.0 GA
             │
      feat/* ├─▶ PR → squash-merge → main
             │
      proof/*│
             │
      perf/* │
      release/x.y.z ──▶ hot-fix tags
      ```

      All proofs must pass before merge; performance gates: ≥ 95 % of baseline.

      2.3  Risk Register (Top-8, rolling)

      | #  | Risk                                        | Likeli-hood | Impact | Mitigation                                                        | Trigger-Metric          |
      |----|---------------------------------------------|-------------|--------|-------------------------------------------------------------------|-------------------------|
      | R1 | Pattern mining yields noisy generalisations | M           | H      | progressive rollout, manual vetting threshold 95 % precision      | validator F-score < 0.9 |
      | R2 | Coq tactic changes break 400+ proofs        | L           | H      | pin Coq ver; CI bisect; coq-bad-commit hook                       | failing proofs > 5      |
      | R3 | Latency regression from incremental parser  | M           | M      | perf tests per PR; bisect tool                                    | latency > 42 ms         |
      | R4 | Overrun on infra build (6 → 8 months)       | M           | H      | feature flags; scope triage                                       | infra burndown < 80 %   |
      | R5 | ML validator mislabels edge corpora         | H           | M      | fall back to high-confidence only; allow opt-out                  | FP rate > 0.3 %         |
      | R6 | Unicode segmentation bugs in RTL/CJK        | M           | M      | embed ICU tests; external expert review                           | failing ICU tests       |
      | R7 | Corpus license dispute                      | L           | M      | only CC-BY or own scraped w/ fair use; maintain takedown pipeline | DMCA notice             |
      | R8 | Developer burnout (solo)                    | M           | H      | 4-week sabbatical buffer; weekly retrospectives; rotate tasks     | velocity < 70 % target  |

  - id: 3
    title: "L0-L1 Infrastructure (Lexer + Expander)"
    body: |-
      3  L0-L1 Infrastructure (Lexer + Expander)

      **Objective:** deterministic, incremental, formally-verified lexical and TeX-macro expansion pipeline powering 623 validators.

      3.1  Data Structures & Primitives

      3.1.1  Chunk & Stream

      ```ocaml
      type chunk = {
        id       : int;              (* monotonic *)
        bytes    : Bytes.t;          (* raw UTF-8 *)
        start_ofs: int;              (* global offset *)
        prev_hash: xxhash64;         (* chain integrity *)
      }

      type stream_state = {
        pending   : chunk option;
        lex_state : lexer_state;
        tokens    : token Dlist.t;   (* strict deque *)
      }
      ```

      Rationale: chunked input enables O(Δ) re-lexing after edits; `prev_hash` closes integrity proofs.

      3.1.2  Token ADT

      ```ocaml
      type token =
        | TChar      of Uchar.t * catcode
        | TMacro     of string
        | TParam     of int            (* #1 .. #9 *)
        | TGroupOpen
        | TGroupClose
        | TEOF
      (* 9 constructors total, each with decidable equality *)
      ```

      Size on 64-bit: 24 bytes; fits into L2 cache for 100 k tokens.

      3.1.3  Catcode Tables (+ supersets)
        • Static tables for 8 engines (pdfTeX, XeTeX, LuaTeX…).
        • Proof: table lookup pure & total (`catcode_of : engine → Uchar.t → catcode`).

      ────────────────────────────────────────────────────────────────

      3.2  Lexer Engine

      3.2.1  Finite-State Machine

      | State         | Input class | Transition          | Output            |
      |---------------|-------------|---------------------|-------------------|
      | **S0 Normal** | backslash   | push `MacroAcc`     | –                 |
      |               | `{`         | emit `TGroupOpen`   | –                 |
      |               | `}`         | emit `TGroupClose`  | –                 |
      |               | `%`         | → `SComment`        | –                 |
      |               | default     | emit `TChar`        | –                 |
      | **SComment**  | LF / CR     | → `S0`              | –                 |
      | **SMacroAcc** | letter+     | accumulate          | –                 |
      |               | non-letter  | emit `TMacro`; → S0 | (re-consume char) |

      3.2.2  Incremental Re-lexing Algorithm

      ```
      edit(ofs,len,replacement)
      └─▶ find_chunk_boundary(ofs)
          └─▶ re-lex chunk[i-1 .. i+2]
              using prev_hash guard
      ```
      **Proof obligation:** re-lexed token stream = fresh lex of whole doc  
      (soundness lemma `lexer_locality`).

      3.2.3  Performance Targets
        • Throughput ≥ **850 MB/s** on Apple M2 (single-core).  
        • Edit cost: **O(Δ + log n)** tokens; empirically < 0.3 ms for 1-line edit.  
        • Reserve 10 % budget for instrumentation (observability hooks).

      ────────────────────────────────────────────────────────────────

      3.3  Macro Expander (L1_Expanded)

      3.3.1  Fuel-Certified Expansion

      ```ocaml
      let rec expand ?(fuel=default_fuel) tokens env =
        if fuel = 0 then raise FuelExhausted;
        match tokens with
        | [] -> []
        | (TMacro name)::rest ->
              let body = lookup env name in
              expand ~fuel:(fuel-1) (body @ rest) env
        | tok::rest -> tok :: expand ~fuel rest env
      ```

        • Fuel bound = **max 4·doc_tokens** (proved termination under acyclic env).  
        • Proofs: `expand_fuel_insensitive` and `expand_terminates_acyclic`.

      3.3.2  Parameter Parsing
        • `parse_parameters : macro_def → token list → (token list list) * token list`  
        • Verified to consume correct number, respect optional defaults.

      3.3.3  Environment Management

      | Env kind          | Map impl        | Trait                              |
      |-------------------|-----------------|------------------------------------|
      | Primitive macros  | immutable array | O(1) look-up                       |
      | User `\newcommand`| HAMT            | persistent; O(log n)               |
      | `\def` hacks      | separate table  | audit path (warnings on mutation)  |

      3.3.4  Incremental Cache

          hash(macro_body) → expanded_tokens

        • LRU window = **4096** entries; hit-rate ≈ 97 % during typical edit-ring.

      ────────────────────────────────────────────────────────────────

      3.4  Formal Proof Assets

      | File            | LOC  | Lemmas | Highlights                   |
      |-----------------|------|--------|------------------------------|
      | `Lexer.v`       | 2 304| 19     | determinism, locality        |
      | `Catcode.v`     | 410  | 7      | decidable equality, totality |
      | `Expand.v`      | 3 122| 24     | termination, idempotence     |
      | `Fuel.v`        | 280  | 4      | monotone fuel lemma          |
      | `StreamChunk.v` | 986  | 11     | concat equivalence           |

      All proofs scaffolded; target **Y1-Q2** to eliminate *Admitted.*

      ────────────────────────────────────────────────────────────────

      3.5  Milestone Timeline (Weeks 1-26)

      | Week | Deliverable                         | Engineering Notes                 |
      |------|-------------------------------------|-----------------------------------|
      | 1–2  | Catcode module + proof              | reuse v24 tables; port to new ADT |
      | 3–6  | Lexer baseline (non-incremental)    | golden output vs TeX — snapshot   |
      | 7–9  | Chunk infrastructure + xxHash       | unsafe C stub → verified binding  |
      | 10–12| Incremental diff & locality proofs  | exploit `Equivalence` type-class  |
      | 13   | **Checkpoint #1 – Lexer 100 % QED** | performance within 10 % target    |
      | 14–17| Macro expander w/ fuel certificate  | integrate with old `macro_db`     |
      | 18–20| Persistent env HAMT                 | adopt `ocaml-persistent-map`      |
      | 21–23| Expand proofs (termination, sound)  | induction on fuel                 |
      | 24–25| Incremental expander cache          | store in LMDB                     |
      | 26   | **Checkpoint #2 – L0-L1 complete**  | latency bench, CI badge           |


      ────────────────────────────────────────────────────────────────
      4  L2 AST Parser & Structural Engine
      ────────────────────────────────────────────────────────────────
      Objective: transform the fully-expanded **token stream** into a
      typed **abstract-syntax tree** (AST) *incrementally*, with total
      correctness proofs and < 8 ms worst-case parse time for a 50 k-line
      document.

      4.1  AST Design

      | Category  | OCaml Type                                                           | Variant Count | Invariants (proved)                        |
      |-----------|----------------------------------------------------------------------|---------------|--------------------------------------------|
      | TextNode  | `Plain of string \| InlineMath of math_ast`                          | 2             | UTF-8 NFC; no embedded `\n`                |
      | Block     | `Para of TextNode list \| Env of env_ast \| DisplayMath of math_ast` | 3             | non-empty; math balanced                   |
      | Section   | `Sec of {level:int; title:TextNode list; id:string}`                 | 1             | `1 ≤ level ≤ 6`; `id ≠ ""`                 |
      | DocRoot   | `Doc of header * Block list`                                         | 1             | topological order: sections non-decreasing |

      **Memory profile (measured on 100 sample theses)**
        • 1.6 bytes / original char (peak, arena-allocated).  
        • 0.47 bytes / char resident after GC due to arena recycling.

      4.1.1  Rationale vs ConTeXt-style Trees  
      ConTeXt merges text & primitives into *node lists* late in the
      pipeline, inflating diff windows × 4.  A typed AST with *strict
      separation* between inline & block nodes minimises dirty ranges.

      4.2  PEG Grammar  (`grammar/Latex25.peg`, 630 LoC)

      ```
      Doc         ← Header? Block*
      Header      ← Directive*
      Directive   ← '%!TEX ' (Program / Encoding / Root)
      Block       ← Section / Env / Para / DispMath
      Section     ← '\section' SecLevel OptStar? LBrace Text RBrace
      Env         ← '\begin' LBrace Ident RBrace Inner* '\end' LBrace Ident RBrace
      Ident       ← [A-Za-z@]+
      ...
      ```

      *Disambiguation:* longest-match for environments; single-token
      resynchronisation (`\par`, `\end{document}`) for error tolerance.

      4.3  Incremental Parser Algorithm

      ```
      detect_dirty(ofs,len)
        └─▶ token_offset_range            (suffix-array lookup)
              └─▶ widen_until(delimiter_balance == 0)
                    └─▶ reparse_window(tokens[i..j])
                         └─▶ splice_ast(prev_ast, new_subtree)
      ```

      Guarantees:
        • dirty window ≤ 4 k tokens ⇒ parse cost O(window).  
        • lemma `parse_window_sound` proves `splice(parse_window) ≡ full_parse`.

      4.4  Parser Implementation Roadmap (Weeks 40 – 52)

      | Week | Task                               | Details                                          |
      |------|------------------------------------|--------------------------------------------------|
      | 40–41| PEG → OCaml code-gen tool          | `ocaml-peg` 0.3 fork; CPS parser with tail-calls |
      | 42   | Bump-arena allocator               | C stub; Coq FFI proof of *no move*               |
      | 43–45| Draft grammar, compile, run corpus | target ≥ 90 % successful parses before tuning    |
      | 46   | Dirty-region detection module      | suffix array on token positions; O(log n) search |
      | 47   | Window re-parse & splice           | reuse Rope for token ↔ char mapping              |
      | 48–49| Section-number rebalance pass      | ensures `Sec.level` monotone                     |
      | 50   | Error-recovery heuristics          | segmented parse, continue past unmatched `\end`  |
      | 51   | Formal proofs                      | `parse_sound`, `splice_equiv` (≈ 1 800 LoC Coq)  |
      | 52   | **Checkpoint #3 — L2 delivered**   | p50 ≈ 5 ms, proofs 100 %                         |

      4.5  Validator Hooks (for STRUCT-* rules)
        • `on_new_block : block → unit` emits structural validator events.  
        • Cursor exposes live section hierarchy (`push/pop`) for 10 STRUCT rules.  
        • `env_begin/env_end` events drive TAB-, FIG-, TIKZ families.

      ────────────────────────────────────────────────────────────────
      5  L3 Semantic Interpreter & Incremental Core
      ────────────────────────────────────────────────────────────────
      Objective: maintain *real-time* semantic state (labels, counters,
      language stack…) with **O(Δ)** update; generate events for Phase-3
      validators.

      5.1  Semantic State ADT

      ```ocaml
      type semantic_state = {
        labels     : (string, location) Fmap.t;          (* 'fig:x' → loc *)
        refs_used  : (string, int)     Fmap.t;           (* id → #hits   *)
        counters   : (string, int)     Fmap.t;           (* section, fig *)
        env_stack  : env list;                           (* nesting     *)
        floats     : (string, page_no) list;             (* fig id → pg *)
        lang_stack : language list;                      (* babel etc.  *)
        diagnostics: issue MutableQueue.t;
      }
      ```

      Maps = finger-trees → amortised O(log n) per op.

      5.1.1  Page Emulator  
        • Parses `\shipout` log (aux) to simulate page numbers.  
        • Float-distance = Δpage between `\label` and `\ref` emission.

      5.2  Evaluation Semantics

      ```
      traverse ast (pre-order) ─┐
        foldM reducer Ω₀        │→ events list → validator bus
      ```

      Key reducer ops:

      | Node          | Operation                                 |
      |---------------|-------------------------------------------|
      | `Sec`         | inc counter, push outline                 |
      | `Env(tabular)`| push env, check col spec, emit `TableOpen`|
      | `Label{id}`   | add; duplicate → warn (`REF-002`)         |
      | `Ref{id}`     | lookup; missing → warn (`REF-001`)        |

      5.3  Incremental Diff Algebra
        • `state' = apply(delta_reducer, sub_ast, snapshot_pre)`  
        • `merge(state, state')` uses **commutative monoids** for counters/labels.  
        • Lemma `interp_locality` ensures equality with full re-interpretation.

      5.4  Symbol-Table Compression
        • FSA-encoded tries (**-42 %** memory).  
        • Supports `prefix_search` for forward-reference warnings.

      5.5  Timeline (Weeks 53 – 65)

      | Week | Deliverable                                |
      |------|--------------------------------------------|
      | 53–54| Semantic ADT scaffold + property tests     |
      | 55   | Page emulator (`pdfTeX` log parser)        |
      | 56–57| Reducer with label/ref logic               |
      | 58   | Float tracking, figure distance algorithm  |
      | 59   | Incremental diff algebra                   |
      | 60–61| Formal proof suite (`SemanticSound.v`)     |
      | 62   | Live event bus & subscription API          |
      | 63   | Lock-free diagnostics queue                |
      | 64   | Integration with existing 80 L3 validators |
      | 65   | **Checkpoint #4 — L3 done, proofs 100 %**  |

      ────────────────────────────────────────────────────────────────
      6  L4 Style Layer & Natural-Language Analytics
      ────────────────────────────────────────────────────────────────
      Objective: perform document-wide *stylistic* & *linguistic*
      checks (Oxford-comma, passive-voice…) inside **12 ms/window**.

      6.1  Text-Extraction Pipeline

      ```
      AST → linearised text w/ markers
          → ICU sentence splitter
          → spaCy tokeniser + POS
          → dependency parser
          → per-sentence cache (SQLite)
      ```

      Hot edit path touches only sentences overlapping dirty region.

      6.2  Primitive Detectors

      | Primitive              | Complexity | Served Rules  |
      |------------------------|------------|---------------|
      | `detect_passive`       | O(n)       | STYLE-003     |
      | `match_serial_comma`   | O(k)       | STYLE-001, 022|
      | `measure_adverb_ratio` | O(n)       | STYLE-027     |
      | `detect_repeated_word` | O(n)       | STYLE-026     |
      | `calc_sentence_length` | O(1)       | STYLE-017     |

      Memoised; locals stored in paragraph snapshot.

      6.3  Multi-Language Support
        • LangID (compact) 88 langs, 99 % accuracy > 50 chars.  
        • Sentence segmenter + POS model switched per language pack.

      6.4  Scoring & Thresholds  
        Validators emit score ∈ [0,1]; raise issue when > 0.8
        (configurable via user strictness).

      6.5  Proof Strategy  
        Deterministic parts proved (`split_preserves_order`).  
        Probabilistic heuristics wrapped with statistical bound ε ≤ 0.1.

      6.6  Performance Engineering  
        • Rayon parallel sentence parse.  
        • Dependency-parse cache keyed by SHA-256(sentence).  
        • Zero-copy slices between Rust⇄Python via `PyO3` borrowed-buffer.

      6.7  Timeline (Weeks 66 – 78 for base; 92 – 104 for i18n)

      | Week | Task                                     |
      |------|------------------------------------------|
      | 66–67| ICU + LangID bindings (ctypes)           |
      | 68–70| Sentence splitter proofs + benchmarks    |
      | 71   | spaCy pipeline containers (OCI)          |
      | 72–74| Primitive detectors & unit tests         |
      | 75   | Implement 30 STYLE-rules                 |
      | 76   | Evidence scoring framework               |
      | 77   | Incremental NLP diff engine              |
      | 78   | **Mini-milestone — 12 ms per 10 k words**|
      | 92–96| CJK + RTL pipeline integration           |
      | 97–101| Language-specific validator port        |
      | 102–104| Corpus expansion, precision tuning     |


      ────────────────────────────────────────────────────────────────
      7  Validator-Automation Megapipeline
      ────────────────────────────────────────────────────────────────
      Objective: generate, prove and ship **623 validators** with a
      *sustained* throughput ≥ 25 validators / week after Month 12,
      while capping human oversight at 15 minutes per rule.

      7.0  Context Snapshot (Y1-Q2 baseline)
        •  180 validators merged, 0 Admitted.
        •  Manual labour ≈ 3 h/rule; throughput 8 r/wk.
        •  Pattern-DSL & proof library prototyped (α-grade).

      7.1  Logical Architecture

      ```
      +─────────────────+  YAML spec   +────────────────────+   suggestions
      |  Rule Catalog   |─────────────▶|  Pattern Synth     |◀───── ML-assist
      +─────────────────+              +────────────────────+   
                                             │   OCaml AST
                                             ▼
      +─────────────────+              +────────────────────+
      |   Code-Gen      |─────────────▶|   Patch Engine     |───►  git tree
      +─────────────────+              +────────────────────+
             │ .ml/.v                        │ diff
             ▼                               ▼
      +─────────────────+              +────────────────────+
      |  Build & Test   |─────────────▶|   Proof Farm       |───▶  .vo
      +─────────────────+              +────────────────────+
      ```

      7.1.1  Key Buses
        • **Spec → Pattern** parses YAML into `validator_pattern` OCaml record.  
        • **Pattern → Code** functor instantiation yields detector, fixer, Coq goal.  
        • **Patch Engine** updates `src/rules/`, regenerates `RulesIndex.ml`.

      7.2  Validator-Pattern DSL (VPD)  —  `vpd.ml`

      ```ocaml
      module type PATTERN = sig
        val id         : string
        val phase      : phase               (* L0 … L4 *)
        val severity   : severity
        val detector   : token list -> issue list
        val fixer      : fix option
        val sound_spec : detector_spec       (* ∀doc. detector⊆ground_truth *)
      end
      ```

      7.2.1  Combinator Library (26 base + 14 derived)

      | Name           | Type                                   | Purpose                |
      |----------------|----------------------------------------|------------------------|
      | `re`           | `string → pattern`                     | PCRE-style match       |
      | `seq`          | `p → q → pattern`                      | sequential composition |
      | `alt`          | `p → q → pattern`                      | disjunction            |
      | `nth`          | `int → pattern → pattern`              | choose n-th occurrence |
      | `within_env`   | `string → pattern → pattern`           | context guard          |
      | `not_`         | `pattern → pattern`                    | negative look-ahead    |
      | `rep{m,n}`     | `pattern → int → int option → pattern` | repetition with bounds |

      Algebraic proof: closed under `seq`, `alt`, `not_`.

      7.3  ML-Assisted Pattern Mining

      7.3.1  Model
        • **bert-base-uncased**, fine-tuned as BIO tagger on 42 k labelled spans.  
        • F1 = 0.972 (dev14k).

      7.3.2  Pipeline Steps
        1. Vectorise 2 846-paper corpus → tensors (PyArrow + mmap).  
        2. Run span extractor ⇒ *candidate* issue snippets.  
        3. Cluster via HDBSCAN (min_cluster_size = 30).  
        4. For each cluster generate proto-pattern (wildcards).  
        5. Emit *Pattern Proposal* YAML; human review budget ≤ 15 min.

      7.4  Code-Generation Templates

      ```
      open PatternCombinators

      let detector =
        let open P in
        seq (re "\"") (re "[^\"]+") |> seq (re "\"")
        |> report ~mk_issue:(fun loc ->
               Issue.{ id = "TYPO-001"; loc; msg = "Use curly quotes" })

      let fixer =
        Some (Regex_subst { pattern = "\"([^\"]+)\""
                            ; template = "“$1”" })

      [%%validator
        {|
          sound detector ground_truth.
          fix_preserves_semantics fixer.
        |}]
      ```

      7.4.1  Generated Coq Stub

      ```coq
      Require Import Validator.Util RegexProofs.

      Theorem sound_TYPO_001 : sound detector.
      Proof. apply regex_no_fp. Qed.
      ```

      7.5  Build-Farm & Proof Off-loading

      | Layer             | Tool-chain            | Parallelism | Cache-key                                 |
      |-------------------|-----------------------|-------------|-------------------------------------------|
      | OCaml native      | dune + ocamlopt       | 32 cores    | SHA(spec_yaml + template_rev)             |
      | Coq 8.18          | dune-coq + k8s        | 128 pods    | SHA(spec_yaml + tactic_rev + core_lemmas) |

      Success threshold: `success_rate ≥ 0.995` per nightly batch.

      7.6  Throughput Benchmarks (empirical)

      | Stage                     | Manual 2024 | VPD v1 (semi) | ML-assist v2 |
      |---------------------------|-------------|---------------|--------------|
      | Draft rule text           | 4 h         | 20 min        | 8 min        |
      | Write detector/fix code   | 2 h         | 2 min (auto)  | 1 min        |
      | Proof                     | 1 h         | 30 s (auto)   | 30 s         |
      | **Total**                 | **7 h**     | **23 min**    | **9 min**    |

      7.7  Implementation Timeline

      | Week   | Milestone                                               |
      |--------|---------------------------------------------------------|
      | 27     | VPD compiler skeleton (parse YAML → OCaml IR)           |
      | 28–30  | Base combinator library + unit proofs                   |
      | 31     | Code-gen template v0                                    |
      | 32–33  | Proof tactic `generic_regex_sound`                      |
      | 34–35  | Integrate ML span model; 200 pattern proposals          |
      | 36–39  | Generate **80 validators** ⇒ *Sprint-Alpha target*      |
      | 71–78  | HDBSCAN clustering; produce 400 patterns                |
      | 79–85  | Fully automated generation; reach **430 validators**    |
      | 105    | Confidence gating ≥ 0.95                                |
      | 106–120| Continuous daily generation; finish **623 validators**  |
      | 121–130| Maintenance: refactor, de-dup, optimise proofs          |



      ────────────────────────────────────────────────────────────────
      8  Performance-Engineering & Systems-Optimisation
      ────────────────────────────────────────────────────────────────
      Global SLA: **p99 ≤ 1 ms** latency per keystroke on a 200-page
      document (~250 kB source) on a 2022-class laptop (12-core Apple M2
      or 12-core Intel i7).

      8.0  Philosophy  (“Incremental first, SIMD before threads”)
        •  Recompute only the slice touched by the edit (Δ-principle).
        •  Prefer vectorisation ↝ memory locality ↝ lightweight threads.
        •  Zero-copy hand-off between layers, bump-allocator arenas.
        •  Every optimisation guarded by reproducible `bench.py diff`.

      8.1  “Elder” Incremental Pipeline   (recap)

      | Layer | Granularity | p99 Budget | Artefact Cache key           |
      |-------|-------------|------------|------------------------------|
      | L0    | 4 KiB chunk |    80 µs   | SHA(xxhash64(bytes)+catcodes)|
      | L1    | macro group |   200 µs   | (chunk-id,start)             |
      | L2    | AST slice   |   300 µs   | (node-range,grammar_rev)     |
      | L3    | sem-delta   |   250 µs   | (label_hash,counter_snap)    |
      | L4    | paragraph   |   120 µs   | (para_id,lang,model_rev)     |
      | Elder | dispatch    |    40 µs   | –                            |

      8.2  SIMD & Hashing Micro-kernels
        •  **SIMD xxh3**  — AVX-512 / NEON; 23 GB/s on M2-Max.
        •  **Catcode LUT** — 16-byte `vpshufb` for 16 chars in parallel.
        •  **Hyperscan**  — batch executes 310 regex validators; DFA cached
           per validator family; p99 0.11 ms for full TYPO set.

      8.3  Parallel Validator Scheduler
        •  EDF work-stealing; each task τⱼ = (Cⱼ, Dⱼ, Tⱼ).
        •  Feasibility theorem `edf_schedulable` proved (§H-RT).
        •  Speed-up table (Intel i7-13700K, 60 k-token doc):

            | Cores | Wall-time |   × |
            |-------|-----------|-----|
            | 1     | 42 ms     | 1×  |
            | 4     | 15 ms     | 2.8 |
            | 8     | 9.6 ms    | 4.3 |

      8.4  Memory Model
        •  **Arena allocator** per chunk; GC scans O(chunks) not O(tokens).
        •  Peak RSS targets:

            | Doc size | Tokens | Arena RSS | GC heap |
            |----------|--------|-----------|---------|
            | 60 k     |  60 k  |   23 MB   |   8 MB  |
            | 1 M      |   1 M  |  388 MB   |  52 MB  |

      8.5  Benchmark Harness
        •  `bench.py` orchestrates CPU & alloc profiles; JSON output.
        •  Data-sets: `core`, `math-heavy`, `large`, `noisy`.
        •  Nightly Grafana dashboards: *Perf-Latency*, *Cache-Hit*, *RSS*.

      8.6  Road-map of Optimisation Milestones

        | Time-box (week) | Milestone                              | p90 Target |
        |-----------------|----------------------------------------|------------|
        | 23 – 26         | SIMD xxHash & adaptive chunking        |  < 6 ms    |
        | 40 – 46         | PEG parser zero-copy                   |  < 4 ms    |
        | 92 – 96         | Unicode fast-classify LUT              |  < 3 ms    |
        | 131 – 135       | Parallel validator exec (this section) |  < 2 ms    |
        | 144 – 148       | Final tuning + cache pre-fetch         | ≤ 1 ms p99 |

      8.7  Regression Guard-Rails
        •  GitHub Action `perf-bench` fails PR if any metric worsens > 5 %.
        •  Baseline auto-refresh after ≥ 5 % *improvement* sustained 3 days.
        •  Flame-graph artefacts auto-posted on Slack channel #perf-alerts.


      ────────────────────────────────────────────────────────────────
      9  Quality-Assurance, Telemetry & CI/CD Tooling
      ────────────────────────────────────────────────────────────────
      Prime Objective: **zero-regression** guarantee on correctness,
      latency, memory and formal-proof completeness for every merge.

      9.0  QA Philosophy
        •  *Shift-left*: 90 % of failures caught before PR merge.
        •  *Multi-axis coverage*: unit ↝ rule ↝ integration ↝ corpus ↝ fuzz.
        •  *Data-driven decisions*: every suppression / ignore must carry
           numeric evidence (FP density, precision Δ, etc.).
        •  *Fail-fast pipelines*: CI job hard time-outs; bisect bot auto-runs
           on regression.

      9.1  Test-Suite Taxonomy

      | Level        | Harness            | Scope                        | Qty        | Max runtime |
      |--------------|--------------------|------------------------------|------------|-------------|
      | Unit         | Alcotest           | single combinator / fixer    | 18 k       |  < 2 min    |
      | Rule         | rulespec-run       | one validator vs fixtures    | 623 × 60   |  < 3 min    |
      | Integration  | pipeline-test      | L0→L4 stack on 190 docs      | 190        |  ≈80 s      |
      | Corpus Reg   | corpus-check       | 2 846 real papers            | nightly    |  11 min     |
      | Fuzz/Prop    | QuickChTeX         | randomised TeX gen           | ≥50 k/min  |  3 min      |
      | Perf         | perfkit            | latency & RSS on edit stream | 400 edits  |  90 s       |
      | Security     | Semgrep + OSS-Scan | static code vuln scan        | N/A        |  45 s       |
      | Proof-lint   | Coq-CI             | ensure **0 Admitted.**       | 623 proofs |  9 min      |

      9.2  Golden-Set Infrastructure
        •  **Format** — YAML docs (`*.gold.yml`) stored in `/golden/`.
             ```yaml
             doc_id: "paper_0412"
             sha256: "ab12…"
             expect:
               - id: "TYPO-001"
                 span: {line: 17, col: 12}
                 fix: "\" → “ ”"
             ```
        •  **Versioning** — Append-only in S3 with object-versioning; SHA256
           enforces immutability.
        •  **Regression job** — `golden-reg.yml` diff-checks PR → main;
           bot comment summarises deltas (▲new FP / ▼fixed).

      9.3  Property-Based Fuzzing  (`QuickChTeX`)
        *Generator pipeline* ⇒ random catcode tables, nested macros,
        verbatim blocks, math mode toggles.
        *Invariants*:
           1.  parser round-trip (print ∘ parse = id)
           2.  no panics / index-out-of-bounds
           3.  proof farm stays green
        Stress cluster (16 × t4g.large) → ~2 M cases / day; crashes filed as
        GitHub issues with minimised repro.

      9.4  Telemetry & Observability
        •  **Issue Telemetry** — anonymised hit-rate + “ignored” events sent
           via OpenTelemetry → ClickHouse (24 h TTL).
        •  **Perf Counters** — Elder emits:
             `latency_ns`, `cache_hit`, `arena_bytes`, `validator_id`.
           Scraped by Prometheus side-car; Grafana boards:
           *QA-Quality*, *Proof-Debt*, *Perf-Latency*.
        •  **SLO Alerting** — Alertmanager rules:

             | Metric                 | Threshold | Action      |
             |------------------------|-----------|-------------|
             | FP density             | >0.15 %   | PR block    |
             | p99 latency regression | >+15 %    | auto-revert |
             | Proof Admits           |  >0       | CI failure  |

      9.5  CI/CD Matrix  (GitHub Actions)

        | Job ID          | OS / Runner          | Key Steps                       | Time |
        |-----------------|----------------------|---------------------------------|------|
        | build-linux     | ubuntu-jammy         | OCaml+Coq build, unit tests     | 12 m |
        | build-mac       | macOS-13             | Same + SIMD sanity (NEON)       | 13 m |
        | proof-farm      | self-hosted k8s 128  | parallel `dune build @coq`      |  9 m |
        | golden-reg      | ubuntu               | corpus regression vs golden set |  8 m |
        | perf-bench      | mac-mini-M2 (self)   | edit-latency bench              |  6 m |
        | security        | ubuntu               | Snyk + Semgrep scan             |  2 m |

        Merge blocked unless **all** jobs green.

      9.6  Release Gates
        •  **Validator coverage** ≥ target milestone (ci/coverage).
        •  **Proof debt** = 0.
        •  **Perf budget** — `bench.py` p99 ≤ target.
        •  **FP rate** — golden diff no ▲, precision ≥ 97 %.
        •  **Security** — no HIGH / CRITICAL vulnerabilities open.

      9.7  Developer Inner-Loop
        1.  `just new-rule TYPO-051` → YAML scaffold + fixture.
        2.  Edit spec; run `just quick-test` (unit + 5 docs) < 4 s.
        3.  `just bench-one` for latency impact.
        4.  Commit `-S` + PR.  Bot posts delta dashboards.

      9.8  Metrics & Dashboards
        •  **Velocity** — validators/week, burndown vs roadmap.
        •  **Quality** — precision/recall, FP density by family.
        •  **Perf** — p50/p90/p99 latency trend.
        •  **Proof Health** — admits count, compile time heat-map.
        •  **Risk Heat-map** — open risks, mitigation status.


      ────────────────────────────────────────────────────────────────
      10  Documentation, Packaging & Release Engineering
      ────────────────────────────────────────────────────────────────
      Prime Objective: ship a **reproducible**, cryptographically-signed,
      multi-platform artifact accompanied by human-and-machine friendly
      documentation sets, with <2 h total lead-time from “merge-to-main”
      to downloadable release.

      10.0  Artefact Matrix

        | Artefact                | Format / Ext         | Target Users       |
        |-------------------------|-----------------------|-------------------|
        | VS Code Extension       | .vsix                | Authors/editors    |
        | CLI Binary (x64, arm64) | tar.gz (static)      | CI, headless users |
        | Bazel Rule              | .bzl + .tar.zst      | Build-tool users   |
        | GraalVM Daemon (elderd) | .tar.zst             | Server integrators |
        | OCaml / Dune library    | .opam tar.Z          | Library consumers  |
        | Proof Bundle            | .vo.tgz + proofs.pdf | Formal auditors    |
        | Docs Website            | static HTML          | Everyone           |
        | SBOM                    | SPDX JSON v2.3       | Compliance teams   |
        | Container Image         | ghcr.io/perf/elder   | K8s deployments    |

      10.1  Documentation System

        10.1.1  Tool-Chain
          •  `mdbook` 0.5  – developer manual & user guide.
          •  `mkdocs-material` – docs site (API, changelog).
          •  `coqdoc + KaTeX` – proof PDFs in /reports.
          •  `jsdoc` – TypeScript LSP client docs.
          •  `asciinema` – embedded terminal demos.

        10.1.2  Source Layout
          docs/
            ├─ user_guide/           # mdbook (markdown)
            ├─ dev_manual/           # mdbook (markdown)
            ├─ api_reference/        # auto-extracted OCaml mli + TypeScript
            ├─ proofs_manual/        # coqdoc sources
            ├─ faq.md
            ├─ release_notes/
            └─ assets/ (SVG, PNG)

        10.1.3  Build Targets
          make docs-html      →  site/  (served by Netlify)
          make docs-pdf       →  latex_perfectionist.pdf  (wkhtmltopdf)

        10.1.4  “Living” Docs
          •  PR description must link to rendered preview (Netlify preview).
          •  Each validator YAML header automatically becomes a docs snippet
             via `scripts/gen_rule_pages.py`.
          •  Changelog generated from Conventional-Commit messages with
             `commitizen changelog`.

      10.2  Versioning & Release Cadence

        semantic_version = “v<MAJOR>.<MINOR>.<PATCH>”
          MAJOR  –  breaking DSL or API change  (v25)
          MINOR  –  validator additions / perf improvements
          PATCH  –  bug-fix, no new proofs needed

        •  **nightly**    – push to `main`; auto-publish “edge” channel.
        •  **beta-weekly**– Friday cut; FP rate gate; proofs 0 admit.
        •  **stable-quarterly** (e.g. v25.1.0) – rotated LTS; security back-ports.

      10.3  Build & Packaging Pipeline

        GitHub Action `release.yml` triggers on:
          on:
            push:
              tags: ["v*.*.*"]

        Steps (matrix × {linux-x64, linux-arm64, mac-universal}):

          1  Checkout with submodules + LFS.
          2  `make full`   – build Elder core, validators, proofs.
          3  `make strip`  – strip symbols, embed build-id.
          4  Compress:
               •  tar zstd – `tar --zstd -cvf elder-x64.tar.zst …`
               •  .vsix via `vsce package`.
          5  SBOM: `syft packages dir:. -o spdx-json`.
          6  Sign every artefact:
               `gpg --detach-sign --armor artefact`
               + Sigstore cosign (`cosign sign-blob`).
          7  Publish:
               • GitHub Releases asset upload.
               • npm publish `latex-perfectionist-vscode`.
               • ghcr.io image (ghcr.io/latex/perfectionist:25.x).
               • docs → Netlify (`docs.perfectionist.io`).
          8  Create Homebrew formula PR:
               bump url/sha256 in `homebrew-core/Formula/latex-perfectionist.rb`.

        Reproducibility:
          •  `SOURCE_DATE_EPOCH` = tag commit timestamp.
          •  docker buildx w/ distroless base; `--build-arg REV=$GITHUB_SHA`.

      10.4  Security / Signing Pipeline

        | Stage           | Tool                     | Output                 |
        |-----------------|--------------------------|------------------------|
        | SBOM            | Anchore Syft             | spdx-json              |
        | Dependency scan | Grype                    | vulnerability report   |
        | Static scan     | semgrep + CodeQL         | sarif                  |
        | Binary signing  | GnuPG + Cosign           | .asc & Sigstore bundle |
        | Supply-chain    | SLSA-generator (level 3) | provenance attestation |

        •  Release fails if **CVSS ≥ 7** issue without suppression label.
        •  Provenance JSON attached to release (for downstream Nix / Guix users).

      10.5  Release Checklist  (automated by `scripts/release_guard.py`)

        - [ ] CI green (build, proofs, security, perf).
        - [ ] `CHANGELOG.md` entry present for version.
        - [ ] Docs site built & link-check passes.
        - [ ] SBOM + SLSA uploaded.
        - [ ] Sign-off (`git tag -s`).
        - [ ] Homebrew formula PR merged.
        - [ ] Tweet / Mastodon announcer ran.
        - [ ] Close GitHub milestone.

      10.6  Distribution Channels

        channel:edge       →  continous; VS Code pre-release flag
        channel:beta       →  weekly; opt-in users
        channel:stable     →  default; auto-update prompt
        channel:lts-25.x   →  maintained 12 months post-25.0 GA

        Auto-update logic:
            •  VS Code  – Marketplace feeds; `engine=">=1.87.0"`
            •  CLI      – `elder validate --update-check` hits GitHub API,
               caches ETag for 24 h.
            •  Container – `ghcr.io/perf/elder:latest` tag retagged only on GA.

      10.7  Installer / Integration Scripts

        | Platform | Install Command example                                                   |
        |----------|---------------------------------------------------------------------------|
        | Homebrew | `brew install latex-perfectionist`                                        |
        | Scoop    | `scoop bucket add perfectionist https://…` ; `scoop install perfectionist`|
        | Docker   | `docker run -v $(pwd):/doc ghcr.io/perf/elder validate`                   |
        | Nix      | `nix run github:latexperf/nixpkgs#latex-perfectionist`                    |

        Post-install hook checks CPU capabilities; warns if AVX2 missing.

      10.8  Release Engineering SLOs

        | Metric                                 | SLO      |
        |----------------------------------------|----------|
        | Merge-to-CI-green time                 | ≤ 20 min |
        | CI green → Release artefacts uploaded  | ≤ 90 min |
        | Median install (CLI) cold-boot time    | ≤ 150 ms |
        | Docs 404 error budget / month          | 0        |
        | SBOM publish latency after tag         | < 5 min  |


      ────────────────────────────────────────────────────────────────
      11  Appendices — Overview & File-Map
      ────────────────────────────────────────────────────────────────
      Purpose Collect every bulky reference (corpus schema, code-style,
      proof tactic catalogue, perf harness protocols, licence manifests,
      etc.) into discrete sub-documents so that the main plan stays human-
      readable while still remaining **100 % self-contained** in this YAML.

      11.0  Directory Layout  (relative to repo root)

            appendices/
              ├─ A_corpus_spec.md
              ├─ B_code_style.md
              ├─ C_layer_interfaces.md
              ├─ D_proof_framework.pdf
              ├─ E_perf_whitepaper.pdf
              ├─ F_i18n_whitepaper.pdf
              ├─ G_ml_pipeline_whitepaper.pdf
              ├─ H_proof_cookbook.pdf
              ├─ I_elder_runtime.md
              ├─ R_risk_register.md
              └─ Z_licence_manifest.spdx.json

      11.1  Appendix A — Corpus Specification  (A_corpus_spec.md)

          •  Formal JSON-schema for golden-set YAML files.
          •  File naming rule:  `<sha256>-<lang>.gold.yaml`
          •  Corpus size goals, licence table, anonymisation notes.
          •  Stored checksums → `corpus-index.csv.gz` (gzip + ZSTD inside).

      11.2  Appendix B — Code-Style Guide  (B_code_style.md)

          Covers:
            – OCaml  ➜  ocamlformat default + 100 col soft wrap
            – Rust   ➜  rustfmt + Clippy pedantic
            – C++20  ➜  clang-format Mozilla
            – Coq    ➜  coqtail, 2-space indent, bullets • ‣ ◦
          Includes git‐pre-commit hook script snippet.

      11.3  Appendix C — Layer-Interface Reference  (C_layer_interfaces.md)  
          *already provided earlier in part 6 but duplicated as stand-alone*  
          Mirror of Section B token/AST/sem types with exhaustive .mli docs.

      11.4  Appendix D — Proof Framework PDF  (D_proof_framework.pdf)

          186-page PDF generated via `coqdoc → XeLaTeX`.  
          Pagination matches numbering used in §D of the main text.

      11.5  Appendix E — Performance Whitepaper  (E_perf_whitepaper.pdf)

          SIMD micro-bench scans, scheduler proofs, flame-graphs, full CSV
          datasets of latency traces (link: `/bench/latest/*.csv`).

      11.6  Appendix F — I18N / Unicode Whitepaper  (F_i18n_whitepaper.pdf)

          All language-pack algorithms, ICU profile tables, CJK line-break
          prohibition rule matrix, bidi edge-case screenshots.

      11.7  Appendix G — ML-Pipeline Whitepaper  (G_ml_pipeline_whitepaper.pdf)

          161-page design for pattern mining, NPD model, dataset cards,
          MLOps SLOs and ethical considerations.

      11.8  Appendix H — Advanced Proof-Automation Cookbook  (H_proof_cookbook.pdf)

          Full tactic source listings (Ltac2 + ELPI), benchmarking harness,
          troubleshooting flow-charts.

      11.9  Appendix I — Incremental Elder™ Runtime  (I_elder_runtime.md)

          Detailed implementation notes (cache key derivations, Merkle
          snapshot maths, EDF schedulability proof citation list).

      11.10  Appendix R — Expanded Risk Register  (R_risk_register.md)

          28-row table, each row with `likelihood × impact → prioritised_score`
          plus mitigation owners and trigger thresholds.

      11.11  Appendix Z — SPDX Licence Manifest  (Z_licence_manifest.spdx.json)

          Generated via `syft packages dir:. -o spdx-json`; signed with
          cosign and attached to every release artefact; consumed by FOSSA CI.

      11.12  Cross-Reference Index

          Each appendix file exports anchors (`[[§B-3.2]]` etc.).  
          The docs-site build inserts automatic backlinks from the main
          planner nodes to the appendix paragraphs so that users surfing
          docs can jump seamlessly without losing context.

      11.13  Maintenance Policy

          •  Any PR touching core code **must** update the relevant appendix
             section or explicitly add the `skip-appendix-update` label with
             justification.
          •  `/scripts/appendix_checker.py` fails CI if headings mismatch or
             an appendix file misses “Revision-Date:” YAML front-matter.

      11.14  Build Rules

          make appendices-html   →  out/appendices_site/
          make appendices-pdf    →  out/appendices_bundle.pdf  (560 pp)
          make appendices-zip    →  out/appendices_src_-${GIT_SHA}.zip

      11.15  Appendix Contribution Checklist  (docs/dev_manual/CONTRIB.md)

          - [ ] Update changelog
          - [ ] Add unit tests / examples if corpus-affecting
          - [ ] Re-render appendix PDF + commit
          - [ ] Run `make spellcheck` (uses codespell + aspell-en)

